#!/usr/bin/env python3

from typing import Optional

from .misc import matches_any_regex


def make_dir_tree(
        combined_ast: dict,
        last: bool=True,
        header: str='',
        lines: Optional[list[str]]=None,
        adoc_links: bool=False,
        adoc_anchors: bool=False
    ) -> str:
    """converts abstract syntax tree to tree-like output

    Parameters
    ----------
    combined_ast: dict
                  abstract syntax tree generated by Parser class
    last:         bool, default=True
                  used in recursion; set True if node is last node in a branch
    header:       str, default=""
                  used in recursion; contains tree symbols preceeding the current line of the output
    lines:        list of str, optional
                  used in recursion; holds the previously generated lines of output
    adoc_links:   bool, default=False
                  if True, adds adoc compatible relative links to each file in the tree
    adoc_anchors: bool, default=False
                  if True, adds adoc compatible links to anchors for use in the same adoc document

    Returns
    -------
    str
        tree-like output generated from ast
    """

    elbow = "└── "
    pipe = "│   "
    tee = "├── "
    blank = "    "

    if combined_ast is None:
        return ""

    if lines is None:
        lines = []

    unpacked = list(combined_ast.values())[0]
    basename = list(combined_ast.keys())[0]
    if adoc_links:
        if adoc_anchors and unpacked["type"] == "file":
            lines.append(f"{header}{(elbow if last else tee)}link:{unpacked["rel_path"]}[{basename}] (<<src-{unpacked["file_idx"]},details>>)")
        else:
            lines.append(f"{header}{(elbow if last else tee)}link:{unpacked["rel_path"]}[{basename}]")
    else:
        if adoc_anchors and unpacked["type"] == "file":
            lines.append(f"{header}{(elbow if last else tee)}{basename} (<<src-{unpacked["file_idx"]},details>>)")
        else:
            lines.append(f"{header}{(elbow if last else tee)}{basename}")

    if unpacked["type"] == "directory":
        children = unpacked["contents"].keys()
        for i, c in enumerate(children):
            make_dir_tree(
                {f"{c}": unpacked["contents"][c]},
                header=header + (blank if last else pipe),
                last=i == len(children) - 1,
                lines=lines,
                adoc_links=adoc_links,
                adoc_anchors=adoc_anchors
            )

    return "\n".join(lines)


file_idx = 0

def add_file_idx(node: dict) -> dict:
    """recursively goes through node and adds unique idx to each file

    Parameters
    ----------
    node: dict
          (part of) combined abstract syntax tree (depending on current recursion step)

    Returns
    -------
    dict
        new (part of) combined abstract syntax tree (depending on current recursion step)
    """
    global file_idx

    unpacked = list(node.values())[0]
    basename = list(node.keys())[0]

    if unpacked["type"] == "file":
        unpacked["file_idx"] = file_idx
        file_idx += 1
        return {basename: unpacked}

    new_contents = {}
    for name, child in unpacked["contents"].items():
        res = add_file_idx({name: child})
        new_contents[name] = list(res.values())[0]

    # Return the directory with modified contents
    return {
        basename: {
            "type": "directory",
            "contents": new_contents,
            "rel_path": unpacked["rel_path"],
        }
    }


def prune_ast(node: dict, include_filters: Optional[list[str]]=None) -> dict | None:
    """recursively prunes directories that do not contain any files (directly or indirectly) or don't match any of the include_filters

    Parameters
    ----------
    node:            dict
                     (part of) combined abstract syntax tree to process
    include_filters: list of str, optional
                     list of include filters (regex) specifying which files/paths to include in result

    Returns
    -------
    dict or None
        remaining (part of) combined abstract syntax tree or None if pruning
    """

    unpacked = list(node.values())[0]
    basename = list(node.keys())[0]

    if unpacked["type"] == "file":
        # Keep only if it matches one of the filters, or if no filters are set
        if not include_filters or matches_any_regex(unpacked["rel_path"], include_filters):
            return node
        else:
            return None

    # Recurse into subdirectories
    new_contents = {}
    for name, child in unpacked["contents"].items():
        pruned = prune_ast({name: child}, include_filters)
        if pruned:
            new_contents[name] = list(pruned.values())[0]

    if not new_contents:
        return None  # Prune empty directory

    # Return the directory with pruned contents
    return {
        basename: {
            "type": "directory",
            "contents": new_contents,
            "rel_path": unpacked["rel_path"],
        }
    }
